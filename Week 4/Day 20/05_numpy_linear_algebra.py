# 05_numpy_linear_algebra.py - Линейная алгебра

import numpy as np

print("="*60)
print("ЛИНЕЙНАЯ АЛГЕБРА В NumPy")
print("="*60)

# ==========================================
# МАТРИЦЫ
# ==========================================

print("\n1. Создание матриц:")

# Обычная матрица
A = np.array([[1, 2, 3],
              [4, 5, 6],
              [7, 8, 9]])

print(f"Матрица A:\n{A}")

# Единичная матрица (диагональ из 1)
I = np.eye(3)
print(f"\nЕдиничная матрица:\n{I}")

# Диагональная матрица
D = np.diag([1, 2, 3])
print(f"\nДиагональная матрица:\n{D}")

# Случайная матрица
R = np.random.rand(3, 3)
print(f"\nСлучайная матрица:\n{R}")

# ==========================================
# МАТРИЧНОЕ УМНОЖЕНИЕ
# ==========================================

print("\n" + "="*60)
print("2. Матричное умножение:")
print("="*60)

A = np.array([[1, 2],
              [3, 4]])

B = np.array([[5, 6],
              [7, 8]])

print(f"A:\n{A}\n")
print(f"B:\n{B}\n")

# Поэлементное умножение (не матричное!)
element_wise = A * B
print(f"A * B (поэлементное):\n{element_wise}\n")
"""
[[1*5, 2*6],
 [3*7, 4*8]]
"""

# Матричное умножение (правильное)
matrix_mult = np.dot(A, B)
print(f"np.dot(A, B) (матричное):\n{matrix_mult}\n")
"""
[[1*5 + 2*7, 1*6 + 2*8],
 [3*5 + 4*7, 3*6 + 4*8]]

[[19, 22],
 [43, 50]]
"""

# Или оператор @
matrix_mult2 = A @ B
print(f"A @ B (матричное):\n{matrix_mult2}\n")

# ==========================================
# ТРАНСПОНИРОВАНИЕ
# ==========================================

print("\n" + "="*60)
print("3. Транспонирование:")
print("="*60)

A = np.array([[1, 2, 3],
              [4, 5, 6]])

print(f"A:\n{A}")
print(f"Форма: {A.shape}\n")

AT = A.T
print(f"A^T (транспонированная):\n{AT}")
print(f"Форма: {AT.shape}")
"""
Строки становятся столбцами:
[[1, 2, 3],     [[1, 4],
 [4, 5, 6]]  ->  [2, 5],
                  [3, 6]]
"""

# ==========================================
# ОПРЕДЕЛИТЕЛЬ
# ==========================================

print("\n" + "="*60)
print("4. Определитель матрицы:")
print("="*60)

A = np.array([[1, 2],
              [3, 4]])

print(f"A:\n{A}\n")

det = np.linalg.det(A)
print(f"Определитель: {det}")
"""
Определитель 2x2:
det = a*d - b*c
det = 1*4 - 2*3 = -2
"""

# Для 3x3
A3 = np.array([[1, 2, 3],
               [0, 1, 4],
               [5, 6, 0]])

print(f"\nA (3x3):\n{A3}")
det3 = np.linalg.det(A3)
print(f"Определитель: {det3}")

# ==========================================
# ОБРАТНАЯ МАТРИЦА
# ==========================================

print("\n" + "="*60)
print("5. Обратная матрица:")
print("="*60)

A = np.array([[1, 2],
              [3, 4]])

print(f"A:\n{A}\n")

# Обратная матрица
A_inv = np.linalg.inv(A)
print(f"A^-1 (обратная):\n{A_inv}\n")

# Проверка: A * A^-1 = I
I = A @ A_inv
print(f"A @ A^-1:\n{I}")
print("Должна быть единичная матрица")
"""
A * A^-1 = I (единичная матрица)
"""

# ==========================================
# РЕШЕНИЕ СИСТЕМ УРАВНЕНИЙ
# ==========================================

print("\n" + "="*60)
print("6. Решение систем линейных уравнений:")
print("="*60)

"""
Система уравнений:
2x + 3y = 8
3x + 4y = 11

В матричном виде: Ax = b
[[2, 3],     [[x],     [[8],
 [3, 4]]  @   [y]]  =   [11]]
"""

A = np.array([[2, 3],
              [3, 4]])

b = np.array([8, 11])

print(f"Система:\n2x + 3y = 8\n3x + 4y = 11\n")
print(f"A:\n{A}\n")
print(f"b: {b}\n")

# Решить
x = np.linalg.solve(A, b)
print(f"Решение: x = {x[0]}, y = {x[1]}")

# Проверка
check = A @ x
print(f"\nПроверка A @ x = {check}")
print(f"Должно быть b = {b}")

# ==========================================
# СОБСТВЕННЫЕ ЗНАЧЕНИЯ И ВЕКТОРЫ
# ==========================================

print("\n" + "="*60)
print("7. Собственные значения и векторы:")
print("="*60)

A = np.array([[1, 2],
              [2, 1]])

print(f"A:\n{A}\n")

# Вычислить
eigenvalues, eigenvectors = np.linalg.eig(A)

print(f"Собственные значения: {eigenvalues}")
print(f"\nСобственные векторы:\n{eigenvectors}")
"""
Для каждого собственного значения λ:
A @ v = λ * v

где v - собственный вектор
"""

# Проверка для первого
λ1 = eigenvalues[0]
v1 = eigenvectors[:, 0]

print(f"\nПроверка для λ1 = {λ1}:")
print(f"v1 = {v1}")
print(f"A @ v1 = {A @ v1}")
print(f"λ1 * v1 = {λ1 * v1}")

# ==========================================
# НОРМА ВЕКТОРА
# ==========================================

print("\n" + "="*60)
print("8. Норма вектора:")
print("="*60)

v = np.array([3, 4])
print(f"Вектор: {v}")

# L2 норма (евклидова длина)
norm = np.linalg.norm(v)
print(f"\nL2 норма: {norm}")
"""
L2 = √(3² + 4²) = √25 = 5
"""

# L1 норма (манхэттенское расстояние)
norm_l1 = np.linalg.norm(v, ord=1)
print(f"L1 норма: {norm_l1}")
"""
L1 = |3| + |4| = 7
"""

# Бесконечная норма (максимальный элемент)
norm_inf = np.linalg.norm(v, ord=np.inf)
print(f"L∞ норма: {norm_inf}")
"""
L∞ = max(|3|, |4|) = 4
"""

# Нормализация вектора (сделать длину = 1)
v_normalized = v / np.linalg.norm(v)
print(f"\nНормализованный: {v_normalized}")
print(f"Норма нормализованного: {np.linalg.norm(v_normalized)}")

# ==========================================
# СКАЛЯРНОЕ ПРОИЗВЕДЕНИЕ
# ==========================================

print("\n" + "="*60)
print("9. Скалярное произведение:")
print("="*60)

a = np.array([1, 2, 3])
b = np.array([4, 5, 6])

print(f"a = {a}")
print(f"b = {b}")

# Скалярное произведение
dot_product = np.dot(a, b)
print(f"\na · b = {dot_product}")
"""
a · b = 1*4 + 2*5 + 3*6 = 4 + 10 + 18 = 32
"""

# Угол между векторами
cos_angle = dot_product / (np.linalg.norm(a) * np.linalg.norm(b))
angle_rad = np.arccos(cos_angle)
angle_deg = np.degrees(angle_rad)

print(f"\nКосинус угла: {cos_angle:.4f}")
print(f"Угол: {angle_deg:.2f}°")

# ==========================================
# РАНГ МАТРИЦЫ
# ==========================================

print("\n" + "="*60)
print("10. Ранг матрицы:")
print("="*60)

A = np.array([[1, 2, 3],
              [4, 5, 6],
              [7, 8, 9]])

print(f"A:\n{A}\n")

rank = np.linalg.matrix_rank(A)
print(f"Ранг матрицы: {rank}")
"""
Ранг = количество линейно независимых строк/столбцов
Третья строка = 2*вторая - первая (зависима)
Поэтому ранг = 2, а не 3
"""

# Полноранговая матрица
B = np.eye(3)
print(f"\nB (единичная):\n{B}\n")
print(f"Ранг: {np.linalg.matrix_rank(B)}")

print("\n" + "="*60)
print("ИТОГИ:")
print("="*60)
print("""
Линейная алгебра в NumPy:

Операции:
- A @ B - матричное умножение
- A.T - транспонирование
- np.linalg.det(A) - определитель
- np.linalg.inv(A) - обратная матрица

Решение систем:
- np.linalg.solve(A, b) - решить Ax = b
- np.linalg.eig(A) - собственные значения

Векторы:
- np.dot(a, b) - скалярное произведение
- np.linalg.norm(v) - норма (длина)
- np.linalg.matrix_rank(A) - ранг

Применение:
- Машинное обучение (PCA, SVD)
- Компьютерная графика (трансформации)
- Физика (системы уравнений)
- Оптимизация
""")